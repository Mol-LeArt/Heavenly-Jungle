/* (c) Copyright 2020 Pivotal Software, Inc. All Rights Reserved. */
"use strict";

exports.__esModule = true;
exports.AutocompleteInput = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DOWN_KEY = 40;
var ENTER_KEY = 13;
var ESC_KEY = 27;
var TAB_KEY = 9;
var UP_KEY = 38;

var AutocompleteInput = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(AutocompleteInput, _React$Component);

  function AutocompleteInput() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "change", function (e) {
      var value = e.currentTarget.value;

      _this.props.setState({
        hidden: false,
        highlightedSuggestion: 0,
        value: value
      });

      _this.props.onSearch(value, function (suggestedValues) {
        _this.props.setState({
          suggestedValues: suggestedValues
        });
      });
    });

    _defineProperty(_assertThisInitialized(_this), "keyDown", function (e) {
      var _keyCodes;

      var keyCode = e.keyCode;
      var _this$props = _this.props,
          highlightedSuggestion = _this$props.highlightedSuggestion,
          suggestedValues = _this$props.suggestedValues,
          value = _this$props.value,
          _this$props$onPicking = _this$props.onPicking,
          onPicking = _this$props$onPicking === void 0 ? function () {
        return suggestedValues;
      } : _this$props$onPicking;

      var pickItem = function pickItem() {
        var selectableSuggestions = onPicking(suggestedValues);
        e && keyCode === ENTER_KEY && e.preventDefault();

        _this.props.setState({
          highlightedSuggestion: -1,
          hidden: true
        });

        _this.props.onPick(selectableSuggestions[highlightedSuggestion] || {
          value: value
        });
      };

      var keyCodes = (_keyCodes = {}, _keyCodes[DOWN_KEY] = function () {
        var selectableSuggestions = onPicking(suggestedValues);

        _this.props.setState({
          hidden: false,
          highlightedSuggestion: Math.min(highlightedSuggestion + 1, selectableSuggestions.length - 1)
        });

        _this.props.scrollIntoView();
      }, _keyCodes[UP_KEY] = function () {
        _this.props.setState({
          highlightedSuggestion: Math.max(highlightedSuggestion - 1, -1)
        });

        _this.props.scrollIntoView();
      }, _keyCodes[TAB_KEY] = pickItem, _keyCodes[ENTER_KEY] = pickItem, _keyCodes[ESC_KEY] = function () {
        _this.props.setState({
          highlightedSuggestion: -1,
          hidden: true
        });
      }, _keyCodes.noop = function noop() {}, _keyCodes);
      keyCodes[keyCode in keyCodes ? keyCode : 'noop']();
    });

    return _this;
  }

  var _proto = AutocompleteInput.prototype;

  _proto.componentDidMount = function componentDidMount() {
    require('../../css/inputs');

    require('../../css/forms');
  };

  _proto.renderDefault = function renderDefault(props) {
    delete props.setState;
    delete props.highlightedSuggestion;
    delete props.suggestedValues;
    return _react["default"].createElement("input", _extends({}, props, {
      className: (0, _classnames["default"])('autocomplete-input', 'form-control', props.className),
      type: "search",
      value: props.value,
      "aria-label": props.placeholder
    }));
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        autoFocus = _this$props2.autoFocus,
        value = _this$props2.value,
        children = _this$props2.children,
        onPick = _this$props2.onPick,
        onPicking = _this$props2.onPicking,
        onSearch = _this$props2.onSearch,
        scrollIntoView = _this$props2.scrollIntoView,
        props = _objectWithoutPropertiesLoose(_this$props2, ["autoFocus", "value", "children", "onPick", "onPicking", "onSearch", "scrollIntoView"]);

    var otherProps = {
      autoFocus: autoFocus,
      value: value,
      onChange: this.change,
      onKeyDown: this.keyDown
    };
    props = _extends({}, props, otherProps);
    if (!children) return this.renderDefault(props);
    children = _react["default"].Children.map(children, function (e) {
      return _react["default"].cloneElement(e, props);
    });
    return _react["default"].createElement("div", null, children);
  };

  return AutocompleteInput;
}(_react["default"].Component);

exports.AutocompleteInput = AutocompleteInput;

_defineProperty(AutocompleteInput, "propTypes", {
  autoFocus: _propTypes["default"].bool,
  children: function children(props, name) {
    if (props[name] && props[name].length) return new Error('AutocompleteInput can only wrap one element');
  },
  disabled: _propTypes["default"].bool,
  highlightedSuggestion: _propTypes["default"].any,
  onClick: _propTypes["default"].func,
  onFocus: _propTypes["default"].func,
  onPick: _propTypes["default"].func,
  onPicking: _propTypes["default"].func,
  onSearch: _propTypes["default"].func,
  scrollIntoView: _propTypes["default"].func,
  setState: _propTypes["default"].func,
  suggestedValues: _propTypes["default"].array,
  value: _propTypes["default"].string
});

_defineProperty(AutocompleteInput, "defaultProps", {
  autoFocus: null
});

_defineProperty(AutocompleteInput, "DOWN_KEY", DOWN_KEY);

_defineProperty(AutocompleteInput, "ENTER_KEY", ENTER_KEY);

_defineProperty(AutocompleteInput, "ESC_KEY", ESC_KEY);

_defineProperty(AutocompleteInput, "TAB_KEY", TAB_KEY);

_defineProperty(AutocompleteInput, "UP_KEY", UP_KEY);