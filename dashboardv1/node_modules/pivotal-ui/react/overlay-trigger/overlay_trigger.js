/* (c) Copyright 2020 Pivotal Software, Inc. All Rights Reserved. */
"use strict";

exports.__esModule = true;
exports.OverlayTrigger = void 0;

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _scrim_mixin = _interopRequireDefault(require("../mixins/mixins/scrim_mixin"));

var _TetherComponent = _interopRequireDefault(require("../react-tether/TetherComponent"));

var _lodash = _interopRequireDefault(require("lodash.uniqueid"));

var _mixins = _interopRequireDefault(require("../mixins"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TETHER_PLACEMENTS = {
  top: 'bottom center',
  bottom: 'top center',
  left: 'middle right',
  right: 'middle left'
};
var privates = new WeakMap();

var OverlayTrigger = /*#__PURE__*/function (_mixin$with) {
  _inheritsLoose(OverlayTrigger, _mixin$with);

  function OverlayTrigger(props, context) {
    var _this;

    _this = _mixin$with.call(this, props, context) || this;

    _defineProperty(_assertThisInitialized(_this), "triggerShow", function (eventType) {
      return function () {
        _this.show();

        var userCallback = _this.props.children.props[eventType];
        userCallback && userCallback.apply(void 0, arguments);
      };
    });

    _defineProperty(_assertThisInitialized(_this), "triggerHide", function (eventType) {
      return function () {
        _this.hide();

        var userCallback = _this.props.children.props[eventType];
        userCallback && userCallback.apply(void 0, arguments);
      };
    });

    _defineProperty(_assertThisInitialized(_this), "getDelay", function (display) {
      var _this$props = _this.props,
          delay = _this$props.delay,
          delayHide = _this$props.delayHide,
          delayShow = _this$props.delayShow,
          isSticky = _this$props.isSticky;
      if (display && delayShow) return delayShow;
      if (!display && delayHide) return delayHide;
      if (!display && isSticky && !delay) return 50;
      return delay;
    });

    _defineProperty(_assertThisInitialized(_this), "scrimClick", function () {
      return _this.hide();
    });

    _defineProperty(_assertThisInitialized(_this), "setDisplay", function (display) {
      var oldTimeout = privates.get(_assertThisInitialized(_this)).timeout;

      if (display === _this.state.display) {
        clearTimeout(oldTimeout);
        privates.set(_assertThisInitialized(_this), {
          timeout: null
        });
        return;
      }

      var delay = _this.getDelay(display);

      if (oldTimeout && delay) return;
      var timeout;

      if (delay) {
        timeout = setTimeout(function () {
          privates.set(_assertThisInitialized(_this), {
            timeout: null
          });

          _this.setState({
            display: display
          });
        }, delay);
      } else {
        _this.setState({
          display: display
        });
      }

      privates.set(_assertThisInitialized(_this), {
        timeout: timeout
      });
    });

    _defineProperty(_assertThisInitialized(_this), "click", function () {
      _this.setDisplay(!_this.state.display);

      var userCallback = _this.props.children.props.onClick;
      userCallback && userCallback.apply(void 0, arguments);
    });

    _defineProperty(_assertThisInitialized(_this), "show", function () {
      return _this.setDisplay(true);
    });

    _defineProperty(_assertThisInitialized(_this), "hide", function () {
      return _this.setDisplay(false);
    });

    privates.set(_assertThisInitialized(_this), {});
    _this.state = {
      display: props.display
    };
    return _this;
  }

  var _proto = OverlayTrigger.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _mixin$with$prototype;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (_mixin$with$prototype = _mixin$with.prototype.componentDidMount).call.apply(_mixin$with$prototype, [this].concat(args));

    require('../../css/tooltips');
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevProps.display !== this.props.display) this.setDisplay(this.props.display);

    if (prevState.display !== this.state.display) {
      var _this$props2 = this.props,
          onEntered = _this$props2.onEntered,
          onExited = _this$props2.onExited;
      var callback = this.state.display ? onEntered : onExited;
      callback && callback();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (_mixin$with.prototype.componentWillUnmount) _mixin$with.prototype.componentWillUnmount.call(this);
    clearTimeout(privates.get(this).timeout);
  };

  _proto.render = function render() {
    var _this$props3 = this.props,
        children = _this$props3.children,
        isSticky = _this$props3.isSticky,
        overlay = _this$props3.overlay,
        pin = _this$props3.pin,
        placement = _this$props3.placement,
        theme = _this$props3.theme,
        trigger = _this$props3.trigger,
        props = _objectWithoutPropertiesLoose(_this$props3, ["children", "isSticky", "overlay", "pin", "placement", "theme", "trigger"]);

    var display = this.state.display;
    var triggerHandlers = {
      'manual': {},
      'hover': {
        onMouseOver: this.triggerShow('onMouseOver'),
        onMouseOut: this.triggerHide('onMouseOut')
      },
      'focus': {
        onFocus: this.triggerShow('onFocus'),
        onBlur: this.triggerHide('onBlur')
      },
      'click': {
        onClick: this.click
      }
    }[trigger];
    var overlayId = overlay.props.id || (0, _lodash["default"])('overlay');
    overlay = _react["default"].cloneElement(overlay, {
      id: overlayId
    });

    if (isSticky) {
      overlay = _react["default"].cloneElement(overlay, {
        onMouseOver: this.triggerShow('onMouseOver'),
        onMouseOut: this.triggerHide('onMouseOut')
      });
    }

    children = _react["default"].cloneElement(children, _extends({
      'aria-describedby': overlayId
    }, triggerHandlers));
    var classes = (0, _classnames["default"])('tooltip', {
      'tooltip-light': theme === 'light'
    });

    var tetherProps = _extends({
      attachment: TETHER_PLACEMENTS[placement],
      constraints: pin ? [{
        to: 'window',
        attachment: 'together',
        pin: true
      }] : [],
      className: classes,
      classes: {
        'target-attached': 'tooltip'
      }
    }, props);

    return _react["default"].createElement(_TetherComponent["default"], tetherProps, children, display && overlay);
  };

  return OverlayTrigger;
}((0, _mixins["default"])(_react["default"].Component)["with"](_scrim_mixin["default"]));

exports.OverlayTrigger = OverlayTrigger;

_defineProperty(OverlayTrigger, "propTypes", {
  delay: _propTypes["default"].number,
  delayHide: _propTypes["default"].number,
  delayShow: _propTypes["default"].number,
  disableScrim: _propTypes["default"].bool,
  display: _propTypes["default"].bool,
  isSticky: _propTypes["default"].bool,
  onEntered: _propTypes["default"].func,
  onExited: _propTypes["default"].func,
  overlay: _propTypes["default"].oneOfType([_propTypes["default"].node, _propTypes["default"].object]),
  pin: _propTypes["default"].bool,
  placement: _propTypes["default"].oneOf(['top', 'bottom', 'left', 'right']),
  theme: _propTypes["default"].oneOf(['light', 'dark']),
  trigger: _propTypes["default"].oneOf(['hover', 'click', 'focus', 'manual'])
});

_defineProperty(OverlayTrigger, "defaultProps", {
  display: false,
  isSticky: false,
  pin: true,
  placement: 'right',
  theme: 'dark',
  trigger: 'hover'
});